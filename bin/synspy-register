#!/usr/bin/python
#
# Copyright 2015-2017 University of Southern California
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
#

import os
import sys
import pcl
import pcl.registration
import numpy as np
import csv
import vispy.scene
from vispy.scene import visuals
from MDAnalysis.lib.transformations import decompose_matrix
import math

from synspy.analyze.util import centroids_zx_swap
from synspy.register import get_env_grid_scale, register

from scipy.spatial import cKDTree

def find_nearest_pair_idxs(a1, a2, radius, depth=5):
    """Find nearest k-dimensional point pairs between a1 and a2.

       Inputs:
         a1: array with shape (n, k)
         a2: array with shape (m, k)
         radius: maximum euclidean distance between points in a pair
         depth: number of tiers of neighbors to consider per point

       Use greedy algorithm to assign nearest neighbors without
       duplication of any point in more than one pair. Consider up to
       depth fallback pairings for one point if its closer neighbors
       have been claimed by a different point.

       Result: arrays with shape (n,), (m,) as adjacency matrices for each
         element of a1 and a2, respectively. The adjacency values are
         1-based index in range [1, m], [1, k] or the value 0 to represent no
         pairing for that element in a1 or a2.
    """
    dx, pairs = cKDTree(a1).query(a2, depth, distance_upper_bound=radius)
    a1_pairs = np.zeros(a1.shape[0], dtype=np.uint32)
    a2_pairs = np.zeros(a2.shape[0], dtype=np.uint32)
    for d in range(depth):
        for idx2 in np.argsort(dx[:,d]):
            if dx[idx2,d] < radius:
                if a2_pairs[idx2] == 0 and a1_pairs[pairs[idx2,d]] == 0:
                    a2_pairs[idx2] = pairs[idx2,d] + 1
                    a1_pairs[pairs[idx2,d]] = idx2 + 1
    return a1_pairs, a2_pairs

def find_intersection(v1, v2, w1, w2, radius):
    """Find intersection and return (v1only, vpairs, v2only, w1only, wpairs, w2only).

       Inputs:
         v1: array with shape (n, k) of k-dimensional vertices
         v2: array with shape (m, k) of k-dimensional vertices
         w1: array with shape (n,) weights
         w2: array with shape (m,) weights
         radius: maximum euclidean distance for pairs

       If INTENSITY_DISTANCE_RATIO env. variable is set, the vectors
       are extended with weights to make one more dimension, with
       weights scaled by the inverse of this ratio to balance
       intensity units against spatial units.  This step is performed
       prior to nearest-neighbor search.

       Point sets v1 and v2 are intersected to find pair-mappings
       based on nearest neighbor from each set without duplicates.

       If PAIR_MAX_RATIO env. variable is set, pairings are
       disregarded if their intensity ratio is higher than the given
       ratio or lower than the inverse of the given ratio. This step
       is performed after nearest-neighor search.

       The results v1only and v2only are non-matched vertices from
       each set, while vpairs is the matched pairs. The weights are
       likewise split into unmatched and paired elements.

       Results:
         v1only: array with shape (n-x, k) for n-x non-matched vertices from v1
         vpairs: array with shape (x, 2, k) for x matched vertices from v1 and v2
         v2only: array with shape (m-x, k) for m-x non-matched vertices from v2
         w1only: array with shape (n-x,) for weights of vertices in v1only
         wpairs: array with shape (x, 2) for weights of vertices in vpairs
         w1only: array with shape (m-x,) for weights of vertices in v2only

    """
    intensity_per_distance = os.getenv('INTENSITY_DISTANCE_RATIO')
    if intensity_per_distance is not None:
        # convert into 4D
        intensity_per_distance = float(intensity_per_distance)
        ve1 = np.zeros((v1.shape[0], v1.shape[1]+1), dtype=v1.dtype)
        ve1[:,0:v1.shape[1]] = v1[:,:]
        ve1[:,v1.shape[1]] = w1[:] * 1/intensity_per_distance
        ve2 = np.zeros((v2.shape[0], v2.shape[1]+1), dtype=v2.dtype)
        ve2[:,0:v2.shape[1]] = v2[:,:]
        ve2[:,v2.shape[1]] = w2[:] * 1/intensity_per_distance
    else:
        ve1 = v1
        ve2 = v2

    v1_to_v2, v2_to_v1 = find_nearest_pair_idxs(ve1, ve2, radius, depth=min(v1.shape[0], v2.shape[0]))
    pair_weights = np.zeros((v1_to_v2.shape[0],2), dtype=np.float32)

    pair_ratio_threshold = os.getenv('PAIR_MAX_RATIO')
    if pair_ratio_threshold is not None:
        # we want to disregard some pairings with extreme intensity ratios
        pair_ratio_threshold = float(pair_ratio_threshold)
        pair_weights[:,0] = (v1_to_v2 > 0) * w1[:]
        pair_weights[:,1] = (v1_to_v2 > 0) * w2[(v1_to_v2 - 1,) * (v1_to_v2 > 0)]
        pair_weights[:,:] += 0.0001
        pair_ratios = np.abs(pair_weights[:,0] / pair_weights[:,1])
        v1_to_v2[ np.where((pair_ratios > pair_ratio_threshold) + (pair_ratios < 1/pair_ratio_threshold)) ] = 0
        v2_to_v1[ (v1_to_v2[np.where((pair_ratios > pair_ratio_threshold) + (pair_ratios < 1/pair_ratio_threshold))],) ] = 0

    shared = (v1_to_v2 > 0).sum()
    v1only = v1[np.where( v1_to_v2 == 0 ) + (slice(None), )]
    v2only = v2[np.where( v2_to_v1 == 0 ) + (slice(None), )]
    w1only = w1[np.where( v1_to_v2 == 0 )]
    w2only = w2[np.where( v2_to_v1 == 0 )]

    vpairs = np.zeros((shared, 2, v1.shape[1]), dtype=v1.dtype)
    paired_idxs = np.where(v1_to_v2 > 0)[0]
    vpairs[:,0,:] = v1[(paired_idxs, slice(None))]
    vpairs[:,1,:] = v2[(v1_to_v2[(paired_idxs,)] - 1, slice(None))]

    wpairs = np.zeros((shared, 2), dtype=w1.dtype)
    wpairs[:,0] = w1[(paired_idxs,)]
    wpairs[:,1] = w2[(v1_to_v2[(paired_idxs,)] - 1,)]

    rms_dx = (np.square((vpairs[:,1,:] - vpairs[:,0,:])).sum())**0.5
    rms_w  = (np.square((wpairs[:,1] - wpairs[:,0])).sum())**0.5
    print 'Found %d shared points RMS dx=%f i=%f.' % (shared, rms_dx, rms_w)
    return (v1only, vpairs, v2only, w1only, wpairs, w2only)

def get_env_splat_sizes():
    segment_sizes = list(map(float, os.getenv('SEGMENT_SIZES', '30,4').split(',')))
    assert len(segment_sizes) == 2
    return segment_sizes

def renormalize_inplace(arrays):
    maxweight = reduce(max, [ np.percentile(a, 90) for a in arrays if a.shape[0] > 0 ], 1.0)
    for w in arrays:
        w[:] = w[:] * np.float32(1.0/maxweight)
        w[:] = w[:] * (w[:] < 1.0) + (w[:] >= 1.0)

def draw_points(view, a, weights, face_color, size=10):
    scatter = visuals.Markers()
    scatter.set_gl_state(depth_test=False)
    scatter.antialias = False
    colors = np.zeros((weights.shape[0], 4), np.float32)
    for i in range(3):
        colors[:,i] = weights
    colors[:,3] = 1.0
    colors[:,:] *= np.array(face_color, np.float32)
    scatter.set_data(a, edge_color=None, face_color=colors, edge_width=0, size=size)
    view.add(scatter)
    return scatter

def draw_pairs(view, a, weights, face_colors, size=10):
    a2 = np.zeros((a.shape[0] * 2, a.shape[2]), dtype=a.dtype)
    cl = np.zeros((a.shape[0] * 2, 4), dtype=np.float32)

    a2[0::2,:] = a[:,0,:]
    a2[1::2,:] = a[:,1,:]

    cl[:,0:3] = 1.0
    cl[:,3] = 0.3

    lines = visuals.Arrow(connect='segments')
    lines.set_gl_state(depth_test=False)
    lines.antialias = False
    lines.set_data(a2, cl, 1, 'segments')
    view.add(lines)

    return [
        draw_points(view, a[:,0,:], weights[:,0], face_colors[0], size) if a.shape[0] > 0 else None,
        lines if a.shape[0] > 0 else None,
        draw_points(view, a[:,1,:], weights[:,1], face_colors[1], size) if a.shape[0] > 0 else None,
    ]

def dump_zyxw(zyx, w, filename):
    dump_prefix = os.getenv('DUMP_PREFIX')
    if dump_prefix is not None:
        csvfile = open(dump_prefix + filename, 'w')
        writer = csv.writer(csvfile)
        writer.writerow(
            ('Z', 'Y', 'X', 'raw core')
        )
        for i in range(zyx.shape[0]):
            writer.writerow(
                (zyx[i,0], zyx[i,1], zyx[i,2], w[i])
            )
        del writer
        csvfile.close()

def main(filenames):
    zyx_grid_scale = get_env_grid_scale()
    print 'grid scale: %s' % (zyx_grid_scale,)
    nuc_filenames = filenames[0:2]
    syn_filenames = filenames[2:4] if len(filenames) == 4 else None
    M, angles, nuc_parts, syn_parts = register(nuc_filenames, zyx_grid_scale, syn_filenames)

    print('VIEW_MATRIX="%s"' % (
        '[%s]' % ', '.join([
            '[%s]' % ', '.join([
                "%f" % M[i,j]
                for j in range(4)
            ])
            for i in range(4)
        ])
    ))
    print('VIEW_ROTATE="%s"' % ','.join([str(r * 180./math.pi) for r in angles]))

    # get first measure from CMSP 4-tuples
    n1weight = nuc_parts[0][1][:,0]
    n2weight = nuc_parts[1][1][:,0]

    if syn_parts is not None:
        s1weight = syn_parts[0][1][:,0]
        s2weight = syn_parts[1][1][:,0]

    segment_sizes = get_env_splat_sizes()
    nuc_pair_radius = float(os.getenv('NUC_PAIRING_RADIUS', '15.0'))
    syn_pair_radius = float(os.getenv('SYN_PAIRING_RADIUS', '5.0'))

    def array_3d_bbox(aa, merge=None):
        results = np.zeros((2,3), dtype=np.float32)
        for d in range(results.shape[1]):
            results[0,d] = min([ a[:,d].min() for a in aa if a.shape[0] > 0])
            results[1,d] = max([ a[:,d].max() for a in aa if a.shape[0] > 0])
            if merge is not None:
                results[0,d] = min(results[0,d], merge[0,d])
                results[1,d] = max(results[1,d], merge[1,d])
        return results

    # swap ZYX->XYZ and find bbox of clouds for visualization
    nuc1 = centroids_zx_swap(nuc_parts[0][0])
    nuc2 = centroids_zx_swap(nuc_parts[1][0])
    nuc1, nucP, nuc2, n1weight, nPweight, n2weight = find_intersection(nuc1, nuc2, n1weight, n2weight, nuc_pair_radius)
    bbox = array_3d_bbox([nuc1, nucP[:,0,:], nucP[:,1,:], nuc2])
    
    if syn_parts is not None:
        syn1 = centroids_zx_swap(syn_parts[0][0])
        syn2 = centroids_zx_swap(syn_parts[1][0])
        syn1, synP, syn2, s1weight, sPweight, s2weight = find_intersection(syn1, syn2, s1weight, s2weight, syn_pair_radius)
        bbox = array_3d_bbox([syn1, synP[:,0,:], synP[:,1,:], syn2], bbox)
    else:
        syn1 = None
        syn2 = None

    # offset origin to center of bbox and normalize for visualization
    renormalize_inplace([n1weight, nPweight[:,0], nPweight[:,1], n2weight])
    origin = (bbox[1,:] - bbox[0,:]) / 2
    scale = origin.max()
    nuc1 = (nuc1 - origin)/scale
    nuc2 = (nuc2 - origin)/scale
    nucP = (nucP - origin)/scale
    if syn_parts is not None:
        dump_zyxw(centroids_zx_swap(syn1), s1weight, 'syn-tpt1-only.csv')
        dump_zyxw(centroids_zx_swap(synP[:,0,:]), sPweight[:,0], 'syn-tpt1-paired.csv')
        dump_zyxw(centroids_zx_swap(synP[:,1,:]), sPweight[:,1], 'syn-tpt2-paired.csv')
        dump_zyxw(centroids_zx_swap(syn2), s2weight, 'syn-tpt2-only.csv')
        renormalize_inplace([s1weight, sPweight[:,0], sPweight[:,1], s2weight])
        syn1 = (syn1 - origin)/scale
        syn2 = (syn2 - origin)/scale
        synP = (synP - origin)/scale

    bgcolor = os.getenv('BACKGROUND_RGB', '0.15,0.15,0.15')
    bgcolor = tuple([ float(c) for c in bgcolor.split(',') ]) + (1.0,)
    canvas = vispy.scene.SceneCanvas(keys='interactive', show=True, bgcolor=bgcolor)

    scatters = []

    def key_press(event):
        if event.key in {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}:
            mapping = {str(i+1): i for i in range(9)}
            mapping['0'] = 9
            idx = mapping[event.key]
            for s in scatters[idx:idx+1]:
                if s is not None:
                    s.visible = not s.visible
        canvas.update()

    canvas.events.key_press.connect(key_press)

    view = canvas.central_widget.add_view()
    view.set_gl_state(depth_test=False)

    nuc_face_colors = ( (0, 1, 1, 0.4), (1, 1, 0, 0.4) )
    syn_face_colors = ( (0, 0.9, 0.9, 0.9), (1, 1, 0, 0.9) )
    

    scatters.extend([
        draw_points(view, nuc1, n1weight, nuc_face_colors[0], segment_sizes[0]) if nuc1.shape[0] else None,
    ] + (draw_pairs(view, nucP, nPweight, nuc_face_colors, segment_sizes[0]) if nucP.shape[0] else [None, None, None]) + [
        draw_points(view, nuc2, n2weight, nuc_face_colors[1], segment_sizes[0]) if nuc2.shape[0] else None,
    ])

    if syn_parts is not None:
        scatters.extend([
            draw_points(view, syn1, s1weight, syn_face_colors[0], segment_sizes[1]) if syn1.shape[0] else None,
        ] + (draw_pairs(view, synP, sPweight, syn_face_colors, segment_sizes[1]) if synP.shape[0] else [None, None, None]) + [
            draw_points(view, syn2, s2weight, syn_face_colors[1], segment_sizes[1]) if syn2.shape[0] else None,
        ])

    if os.getenv('SHOW_AXES', 'true').lower() != 'false':
        axis = visuals.XYZAxis(parent=view.scene)
    #view.camera = 'turntable'
    view.camera = 'arcball'
    vispy.app.run()
    
    return 0
    
if __name__ == '__main__':
    assert len(sys.argv) >= 3, "usage: synspy-register nucfile1 nucfile2 [synfile1 synfile2]"
    assert len(sys.argv) <= 5, "usage: synspy-register nucfile1 nucfile2 [synfile1 synfile2]"
    result = main(sys.argv[1:])
    sys.exit(result)
