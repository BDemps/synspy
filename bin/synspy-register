#!/usr/bin/python
#
# Copyright 2015-2017 University of Southern California
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
#

import os
import sys
import pcl
import pcl.registration
import numpy as np
import csv
import vispy.scene
from vispy.scene import visuals
from MDAnalysis.lib.transformations import decompose_matrix
import math

from synspy.analyze.util import centroids_zx_swap
from synspy.register import get_env_grid_scale, register

from scipy.spatial import cKDTree

def find_nearest_pair_idxs(a1, a2, radius, depth=5):
    """Find nearest k-dimensional point pairs between a1 and a2.

       Inputs:
         a1: array with shape (n, k)
         a2: array with shape (m, k)
         radius: maximum euclidean distance between points in a pair
         depth: number of tiers of neighbors to consider per point

       Use greedy algorithm to assign nearest neighbors without
       duplication of any point in more than one pair. Consider up to
       depth fallback pairings for one point if its closer neighbors
       have been claimed by a different point.

       Result: arrays with shape (n,), (m,) as adjacency matrices for each
         element of a1 and a2, respectively. The adjacency values are
         1-based index in range [1, m], [1, k] or the value 0 to represent no
         pairing for that element in a1 or a2.
    """
    dx, pairs = cKDTree(a1).query(a2, depth, distance_upper_bound=radius)
    a1_pairs = np.zeros(a1.shape[0], dtype=np.uint32)
    a2_pairs = np.zeros(a2.shape[0], dtype=np.uint32)
    for d in range(depth):
        for idx2 in np.argsort(dx[:,d]):
            if dx[idx2,d] < radius:
                if a2_pairs[idx2] == 0 and a1_pairs[pairs[idx2,d]] == 0:
                    a2_pairs[idx2] = pairs[idx2,d] + 1
                    a1_pairs[pairs[idx2,d]] = idx2 + 1
    return a1_pairs, a2_pairs

def find_intersection(v1, v2, w1, w2, radius):
    """Find intersection and return (v1only, vpairs, v2only, w1only, wpairs, w2only).

       Inputs:
         v1: array with shape (n, k) of k-dimensional vertices
         v2: array with shape (m, k) of k-dimensional vertices
         w1: array with shape (n,) weights
         w2: array with shape (m,) weights
         radius: maximum euclidean distance for pairs

       Point sets v1 and v2 are intersected to find pair-mappings
       based on nearest neighbor from each set without duplicates.

       The results v1only and v2only are non-matched vertices from
       each set, while vpairs is the matched pairs. The weights are
       likewise split into unmatched and paired elements.

       Results:
         v1only: array with shape (n-x, k) for n-x non-matched vertices from v1
         vpairs: array with shape (x, 2, k) for x matched vertices from v1 and v2
         v2only: array with shape (m-x, k) for m-x non-matched vertices from v2
         w1only: array with shape (n-x,) for weights of vertices in v1only
         wpairs: array with shape (x, 2,) for weights of vertices in vpairs
         w1only: array with shape (m-x,) for weights of vertices in v2only
    """
    v1_to_v2, v2_to_v1 = find_nearest_pair_idxs(v1, v2, radius)
    shared = (v1_to_v2 > 0).sum()
    v1only = v1[np.where( v1_to_v2 == 0 ) + (slice(None), )]
    v2only = v2[np.where( v2_to_v1 == 0 ) + (slice(None), )]
    w1only = w1[np.where( v1_to_v2 == 0 )]
    w2only = w2[np.where( v2_to_v1 == 0 )]

    vpairs = np.zeros((shared, 2, v1.shape[1]), dtype=v1.dtype)
    paired_idxs = np.where(v1_to_v2 > 0)[0]
    vpairs[:,0,:] = v1[(paired_idxs, slice(None))]
    vpairs[:,1,:] = v2[(v1_to_v2[(paired_idxs,)] - 1, slice(None))]

    wpairs = np.zeros((shared, 2), dtype=w1.dtype)
    wpairs[:,0] = w1[(paired_idxs,)]
    wpairs[:,1] = w2[(v1_to_v2[(paired_idxs,)] - 1,)]

    return (v1only, vpairs, v2only, w1only, wpairs, w2only)

def get_env_splat_sizes():
    segment_sizes = list(map(float, os.getenv('SEGMENT_SIZES', '30,4').split(',')))
    assert len(segment_sizes) == 2
    return segment_sizes

def renormalize_inplace(arrays):
    maxweight = reduce(max, map(lambda a: np.percentile(a, 90), arrays), 1.0)
    for w in arrays:
        w[:] = w[:] * np.float32(1.0/maxweight)
        w[:] = w[:] * (w[:] < 1.0) + (w[:] >= 1.0)

def draw_points(view, a, weights, face_color, size=10):
    scatter = visuals.Markers()
    scatter.set_gl_state(depth_test=False)
    scatter.antialias = False
    colors = np.zeros((weights.shape[0], 4), np.float32)
    for i in range(3):
        colors[:,i] = weights
    colors[:,3] = 1.0
    colors[:,:] *= np.array(face_color, np.float32)
    scatter.set_data(a, edge_color=None, face_color=colors, edge_width=0, size=size)
    view.add(scatter)
    return scatter

def draw_pairs(view, a, weights, face_colors, size=10):
    fc = np.array(face_colors, dtype=np.float32)

    a2 = np.zeros((a.shape[0] * 2, a.shape[2]), dtype=a.dtype)
    c2 = np.zeros((a.shape[0] * 2, 4), dtype=np.float32)
    
    a2[0::2,:] = a[:,0,:]
    a2[1::2,:] = a[:,1,:]

    c2[0::2,:] = weights[:,0,None] * fc[0,:]
    c2[1::2,:] = weights[:,1,None] * fc[1,:]

    lines = visuals.Arrow(connect='segments')
    lines.set_gl_state(depth_test=False)
    lines.antialias = False
    lines.set_data(a2, c2, size, 'segments')
    view.add(lines)
    return lines

def main(filenames):
    zyx_grid_scale = get_env_grid_scale()
    nuc_filenames = filenames[0:2]
    syn_filenames = filenames[2:4] if len(filenames) == 4 else None
    M, angles, nuc_parts, syn_parts = register(nuc_filenames, zyx_grid_scale, syn_filenames)

    print('VIEW_MATRIX="%s"' % (
        '[%s]' % ', '.join([
            '[%s]' % ', '.join([
                "%f" % M[i,j]
                for j in range(4)
            ])
            for i in range(4)
        ])
    ))
    print('VIEW_ROTATE="%s"' % ','.join([str(r * 180./math.pi) for r in angles]))

    # get first measure from CMSP 4-tuples
    n1weight = nuc_parts[0][1][:,0]
    n2weight = nuc_parts[1][1][:,0]
    renormalize_inplace([n1weight, n2weight])

    if syn_parts is not None:
        s1weight = syn_parts[0][1][:,0]
        s2weight = syn_parts[1][1][:,0]
        renormalize_inplace([s1weight, s2weight])

    segment_sizes = get_env_splat_sizes()

    # swap ZYX->XYZ and find bbox of clouds for visualization
    nuc1 = centroids_zx_swap(nuc_parts[0][0])
    nuc2 = centroids_zx_swap(nuc_parts[1][0])
    
    bbox = np.zeros((2,3), dtype=np.float32)
    bbox[0,:] = np.minimum(nuc1.min(axis=0), nuc2.min(axis=0))
    bbox[1,:] = np.maximum(nuc1.max(axis=0), nuc2.max(axis=0))
    nuc_pair_radius = float(os.getenv('NUC_PAIRING_RADIUS', '15.0'))
    if syn_parts is not None:
        syn1 = centroids_zx_swap(syn_parts[0][0])
        syn2 = centroids_zx_swap(syn_parts[1][0])
        bbox[0,:] = np.minimum(syn1.min(axis=0), bbox[0,:])
        bbox[0,:] = np.minimum(syn2.min(axis=0), bbox[0,:])
        bbox[1,:] = np.minimum(syn1.max(axis=0), bbox[1,:])
        bbox[1,:] = np.minimum(syn2.max(axis=0), bbox[1,:])
        syn_pair_radius = float(os.getenv('SYN_PAIRING_RADIUS', '5.0'))
    else:
        syn1 = None
        syn2 = None

    # offset origin to center of bbox and normalize for visualization
    origin = (bbox[1,:] - bbox[0,:]) / 2
    scale = origin.max()
    nuc1 = (nuc1 - origin)/scale
    nuc2 = (nuc2 - origin)/scale
    nuc1, nucP, nuc2, n1weight, nPweight, n2weight = find_intersection(nuc1, nuc2, n1weight, n2weight, nuc_pair_radius/scale)
    if syn_parts is not None:
        syn1 = (syn1 - origin)/scale
        syn2 = (syn2 - origin)/scale
        syn1, synP, syn2, s1weight, sPweight, s2weight = find_intersection(syn1, syn2, s1weight, s2weight, syn_pair_radius/scale)

    canvas = vispy.scene.SceneCanvas(keys='interactive', show=True, bgcolor=(0.15,0.15,0.15,1))

    scatters = []

    def key_press(event):
        if event.key in {'1', '2', '3', '4', '5', '6', '7', '8'}:
            idx = {str(i+1): i for i in range(9)}[event.key]
            for s in scatters[idx:idx+1]:
                if s is not None:
                    s.visible = not s.visible
        canvas.update()

    canvas.events.key_press.connect(key_press)

    view = canvas.central_widget.add_view()
    view.set_gl_state(depth_test=False)

    nuc_face_colors = ( (0, 1, 1, 0.4), (1, 1, 0, 0.4) )
    syn_face_colors = ( (0, 0.9, 0.9, 0.9), (1, 1, 0, 0.9) )
    

    scatters.extend([
        draw_points(view, nuc1, n1weight, nuc_face_colors[0], segment_sizes[0]) if nuc1.shape[0] else None,
        #draw_points(view, nucP[:,0,:], nPweight[:,0], (1,1,1,0.4), segment_sizes[0]) if nucP.shape[0] else None,
        draw_pairs(view, nucP, nPweight, nuc_face_colors, 40) if nucP.shape[0] else None,
        draw_points(view, nuc2, n2weight, nuc_face_colors[1], segment_sizes[0]) if nuc2.shape[0] else None,
    ])

    if syn_parts is not None:
        scatters.extend([
            draw_points(view, syn1, s1weight, syn_face_colors[0], segment_sizes[1]) if syn1.shape[0] else None,
            #draw_points(view, synP[:,0,:], sPweight[:,0], (0.9,0.9,0.9,0.8), segment_sizes[1]) if synP.shape[0] else None,
            draw_pairs(view, synP, sPweight, syn_face_colors, 3) if synP.shape[0] else None,
            draw_points(view, syn2, s2weight, syn_face_colors[1], segment_sizes[1]) if syn2.shape[0] else None,
        ])

    axis = visuals.XYZAxis(parent=view.scene)
    view.camera = 'turntable'
    vispy.app.run()
    
    return 0
    
if __name__ == '__main__':
    assert len(sys.argv) >= 3, "usage: synspy-register nucfile1 nucfile2 [synfile1 synfile2]"
    assert len(sys.argv) <= 5, "usage: synspy-register nucfile1 nucfile2 [synfile1 synfile2]"
    result = main(sys.argv[1:])
    sys.exit(result)
