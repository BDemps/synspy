#!/usr/bin/python
#
# Copyright 2015-2017 University of Southern California
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
#

import os
import sys
import pcl
import pcl.registration
import numpy as np
import csv
import vispy.scene
from vispy.scene import visuals
from MDAnalysis.lib.transformations import decompose_matrix
import math

from synspy.analyze.util import centroids_zx_swap
from synspy.register import get_env_grid_scale, register

def get_env_splat_sizes():
    segment_sizes = list(map(float, os.getenv('SEGMENT_SIZES', '30,4').split(',')))
    assert len(segment_sizes) == 2
    return segment_sizes

def renormalize_inplace(arrays):
    maxweight = reduce(max, map(lambda a: np.percentile(a, 90), arrays), 1.0)
    for w in arrays:
        w[:] = w[:] * np.float32(1.0/maxweight)
        w[:] = w[:] * (w[:] < 1.0) + (w[:] >= 1.0)

def draw_points(view, a, weights, face_color, size=10):
    scatter = visuals.Markers()
    scatter.set_gl_state(depth_test=False)
    scatter.antialias = False
    colors = np.zeros((weights.shape[0], 4), np.float32)
    for i in range(3):
        colors[:,i] = weights
    colors[:,3] = 1.0
    colors[:,:] *= np.array(face_color, np.float32)
    scatter.set_data(a, edge_color=None, face_color=colors, edge_width=0, size=size)
    view.add(scatter)
    return scatter

def main(filenames):
    zyx_grid_scale = get_env_grid_scale()
    nuc_filenames = filenames[0:2]
    syn_filenames = filenames[2:4] if len(filenames) == 4 else None
    M, angles, nuc_parts, syn_parts = register(nuc_filenames, zyx_grid_scale, syn_filenames)

    print('VIEW_MATRIX="%s"' % (
        '[%s]' % ', '.join([
            '[%s]' % ', '.join([
                "%f" % M[i,j]
                for j in range(4)
            ])
            for i in range(4)
        ])
    ))
    print('VIEW_ROTATE="%s"' % ','.join([str(r * 180./math.pi) for r in angles]))

    # get first measure from CMSP 4-tuples
    n1weight = nuc_parts[0][1][:,0]
    n2weight = nuc_parts[1][1][:,0]
    renormalize_inplace([n1weight, n2weight])

    if syn_parts is not None:
        s1weight = syn_parts[0][1][:,0]
        s2weight = syn_parts[1][1][:,0]
        renormalize_inplace([s1weight, s2weight])

    segment_sizes = get_env_splat_sizes()

    # swap ZYX->XYZ and find bbox of clouds for visualization
    nuc1 = centroids_zx_swap(nuc_parts[0][0])
    nuc2 = centroids_zx_swap(nuc_parts[1][0])
    bbox = np.zeros((2,3), dtype=np.float32)
    bbox[0,:] = np.minimum(nuc1.min(axis=0), nuc2.min(axis=0))
    bbox[1,:] = np.maximum(nuc1.max(axis=0), nuc2.max(axis=0))
    if syn_parts is not None:
        syn1 = centroids_zx_swap(syn_parts[0][0])
        syn2 = centroids_zx_swap(syn_parts[1][0])
        bbox[0,:] = np.minimum(syn1.min(axis=0), bbox[0,:])
        bbox[0,:] = np.minimum(syn2.min(axis=0), bbox[0,:])
        bbox[1,:] = np.minimum(syn1.max(axis=0), bbox[1,:])
        bbox[1,:] = np.minimum(syn2.max(axis=0), bbox[1,:])
    else:
        syn1 = None
        syn2 = None

    # offset origin to center of bbox and normalize for visualization
    origin = (bbox[1,:] - bbox[0,:]) / 2
    scale = origin.max()
    nuc1 = (nuc1 - origin)/scale
    nuc2 = (nuc2 - origin)/scale
    if syn_parts is not None:
        syn1 = (syn1 - origin)/scale
        syn2 = (syn2 - origin)/scale

    canvas = vispy.scene.SceneCanvas(keys='interactive', show=True, bgcolor=(0.15,0.15,0.15,1))

    scatters = []

    def key_press(event):
        if event.key in {'1', '2', '3', '4'}:
            idx = {str(i+1): i for i in range(4)}[event.key]
            for s in scatters[idx:idx+1]:
                s.visible = not s.visible
        canvas.update()

    canvas.events.key_press.connect(key_press)

    view = canvas.central_widget.add_view()
    view.set_gl_state(depth_test=False)

    scatters.extend([
        draw_points(view, nuc1, n1weight, (0,1,1,0.4), segment_sizes[0]),
        draw_points(view, nuc2, n2weight, (1,1,0,0.4), segment_sizes[0]),
    ])

    if syn_parts is not None:
        scatters.extend([
            draw_points(view, syn1, s1weight, (0,0.9,0.9,0.9), segment_sizes[1]),
            draw_points(view, syn2, s2weight, (1,1,0,0.9), segment_sizes[1]),
        ])

    axis = visuals.XYZAxis(parent=view.scene)
    view.camera = 'turntable'
    vispy.app.run()
    
    return 0
    
if __name__ == '__main__':
    assert len(sys.argv) >= 3, "usage: synspy-register nucfile1 nucfile2 [synfile1 synfile2]"
    assert len(sys.argv) <= 5, "usage: synspy-register nucfile1 nucfile2 [synfile1 synfile2]"
    result = main(sys.argv[1:])
    sys.exit(result)
